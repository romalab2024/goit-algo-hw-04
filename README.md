# goit-algo-hw-04
Порівняння трьох алгоритмів сортування: злиттям, вставками та Timsort за часом виконання

Висновок: порівняння алгоритмів сортування

1. Сортування злиттям (Merge Sort)

Аналіз складності: 
 - Алгоритм показує стабільну часову складність O(n log n), незалежно від стану вхідних даних.
 - Це означає, що він добре працює як на випадкових, так і на повністю впорядкованих або обернено впорядкованих масивах.

Практичне використання: 
 - Сортування злиттям добре підходить для роботи з великими масивами, оскільки його складність залишається стабільною.
 - Однак воно використовує додаткову пам’ять для проміжних масивів (в середньому O(n)), що може бути недоліком у системах з обмеженими ресурсами.

2. Сортування вставками (Insertion Sort)

Аналіз складності: 
 - Алгоритм має часову складність O(n²) у найгіршому і середньому випадках.
 - Але у найкращому випадку (коли масив уже майже відсортований) складність складає O(n).

Практичне використання: 
 - Сортування вставками працює добре для невеликих масивів або масивів, які вже частково відсортовані.
 - У великих наборах даних воно демонструє значне зниження продуктивності через квадратичну складність.

Недоліки: 
 - На великих масивах цей алгоритм стає непридатним через занадто довгий час виконання.

3. Timsort (вбудована функція Python)

Аналіз складності: 
 - Завдяки поєднанню сортування вставками і злиттям, Timsort має складність O(n log n) у середньому і найгіршому випадках, і O(n) у найкращому випадку.
 - Алгоритм оптимізований для реального використання, враховуючи частково впорядковані дані.

Практичне використання: 
 - Цей алгоритм використовується як стандартний у Python (функції sorted і list.sort).
 - Його ефективність і стабільність роблять його найкращим вибором для більшості задач сортування.

   Чому Timsort найкращий?
1. Комбінація алгоритмів: Timsort ефективно поєднує сильні сторони сортування злиттям і вставками:

 - Використовує сортування вставками для малих підмасивів (менше певного розміру, за замовчуванням це 32 елементи).
 - Для більших масивів застосовує сортування злиттям.
   
2. Оптимізація частково впорядкованих даних: Timsort розпізнає вже впорядковані підпослідовності ("runs") у вхідних даних і обробляє їх окремо, що значно покращує продуктивність у реальних сценаріях.

3. Ефективне використання пам'яті: Алгоритм використовує мінімум додаткової пам’яті в порівнянні з класичним сортуванням злиттям.

Емпіричні дані:
 - Timsort: Найшвидший на всіх наборах даних завдяки оптимізації.
 - Merge Sort: Показав стабільний час виконання, але трохи повільніший за Timsort через використання додаткової пам'яті.
 - Insertion Sort: На великих наборах даних працює значно повільніше, що підтверджує його обмежену придатність для таких задач.

Загальні висновки
 - Timsort є ідеальним вибором для реальних задач через його високу швидкість і оптимізацію під частково впорядковані дані. Саме тому програмісти переважно використовують вбудовані методи sorted() і sort() у Python.
 - Сортування злиттям є гарним вибором для навчання і розуміння алгоритмів, а також для задач, де пам’ять не є критичним фактором.
 - Сортування вставками має сенс лише для невеликих і частково впорядкованих масивів, але воно не підходить для великих обсягів даних.

Task_2_Optional task

 Детальні висновки

1. Ефективність алгоритму:

 - Використання мін-купи (heapq) дозволяє зменшити складність алгоритму до O(N log k), де N — загальна кількість елементів у всіх списках, а k — кількість списків.
 - Це набагато швидше, ніж простий підхід об'єднання всіх списків у один і застосування сортування, який має складність O(N log N).

2. Тестування на різних наборах даних:

 - Для малих значень k і розмірів списків час виконання дуже малий (менше 0.1 секунди).
 - При збільшенні k (наприклад, до 1000 списків) і великих масивах (10000 елементів у кожному списку) алгоритм працює ефективно завдяки оптимальному використанню мін-купи.
   
3. Переваги методу:

 - Мін-купа дозволяє динамічно знаходити найменший елемент серед усіх списків, що забезпечує високу продуктивність навіть для великих даних.
 - Алгоритм легко адаптується до змін вхідних параметрів (кількість списків, розмір елементів тощо).

4. Практичне застосування:

 - Такий підхід часто використовується в базах даних, пошукових системах та в алгоритмах обробки великих даних, де потрібно швидко об'єднувати і сортувати дані.



